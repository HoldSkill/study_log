# 面试题总结

### 1.网络连接相关

##### 1.1 get和post区别

1.再刷新时，get是无害的，post会再次提交数据
2.get的数据长度受url影响，一般为2048字符，post无限制
3.post比get安全
4.get只允许 ASCII码，post无限制，支持二进制数据
5.get的数据在url中，对所有人是可见的，post在请求体中

##### 1.2 cookie和session的区别

1.cookie存储在客户端中，session存储在服务器中
2.cookie的生命周期是累计，从开始计算，例如：20分钟后失效  session是 开始计时 20分钟有效 19分钟有人访问，从新开始计时
3.cookie安全性较低，session安全性高

**联系**:session_start开启后，session的sessionId会存存在cookie中，客户端下次访问时，通过sessionId获取session信息

##### 1.3 常用的http状态码

| 分类 | 描述                                           |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或者无法完成请求   |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

- 200 - 请求成功
- 301 - 资源(网页等)被永久转移到其他url
- 404 - 请求的资源(网页)不存在
- 500 - 内部服务器错误

##### 1.4 从输入url到页面展示，做了什么

- URL输入
- DNS解析
- TCP连接
- 发送HTTP请求
- 服务器处理请求
- 服务器响应请求
- 浏览器解析渲染页面
- 连接结束

##### 1.5 nginx+php-fpm运行流程

```
 www.example.com
        |
        |
      Nginx
        |
        |
路由到www.example.com/index.php
        |
        |
加载nginx的fast-cgi模块
        |
        |
fast-cgi监听127.0.0.1:9000地址
        |
        |
www.example.com/index.php请求到达127.0.0.1:9000
        |
        |
php-fpm 监听127.0.0.1:9000
        |
        |
php-fpm 接收到请求，启用worker进程处理请求
        |
        |
php-fpm 处理完请求，返回给nginx
        |
        |
nginx将结果通过http返回给浏览器
```

##### 1.6 crontab 如果一个定时任务没有执行完，下一个任务又开始执行了，怎么解决

使用 linux flock 文件锁 来实现任务锁定，解决冲突

```shell
#格式
flock [-sxun][-w #]
flock [-sxon][-w #] file [-c] command
#参数选项
-s, --shared:    获得一个共享锁
-x, --exclusive: 获得一个独占锁/排他锁
-u, --unlock:    移除一个锁，通常是不需要的，脚本执行完会自动丢弃锁
-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待
-w, --timeout:   如果没有立即获得锁，等待指定时间
-o, --close:     在运行命令前关闭文件的描述符号。用于如果命令产生子进程时会不受锁的管控
-c, --command:   在shell中运行一个单独的命令
-h, --help       显示帮助
-V, --version:   显示版本
-w 等待时间,秒
#表示执行sleep.sh脚本时，文件锁使用排他锁，锁定失败不等待，下一周期再进行判断
2/* * * * * flock -xn /tmp/sleep.lock -c /opt/sleep.sh >> /tmp/sleep.log
##表示执行sleep.sh脚本时，文件锁使用排他锁，锁定失败等待20秒
2/* * * * * flock -x -w 20 /tmp/sleep.lock -c /opt/sleep.sh >> /tmp/sleep.log
```



### 2.php相关

##### 2.1 几个常用的魔术方法

1.`__construct()`实例化对象时会被调用
2`__destruct()`销毁对象时会被调用
3.`__call`调用一个不存在的方法时调用
4.`__get`获得一个类的成员变量时调用 调用private时
5.`__set`设置一个类的成员变量时调用 设置私有属性时

##### 2.2 接口和抽象类的区别

1.抽象类前需要加abstract ,接口前需要加interface
2.抽象类需要被extends 接口需要被implements
3.子类和抽象类的抽象方法的参数必须一致，接口不需要
4.抽象类能声明各种变量，接口不能声明变量，只能声明常量
5.一个类可以继承多个接口，只能继承一个抽象类

##### 2.3 常用的设计模式

1.单例模式，经常用于数据库连击
2.工厂模式,经常用于通过不同参数来实例不同得类的情况
3.观察者模式
4.适配器模式 经常用于兼容老代码，或者不兼容的接口

##### 2.4 如何快速获取url的信息

```php
$_SERVER["SERVER_PORT"]  //获取端口  
$_SERVER['HTTP_HOST']  //获取域名或主机地址 如test.cn 或http://www.test.cn 或2010.test.cn  
$_SERVER['SERVER_NAME']  //获取域名或主机地址 注：只是主域名 如 test.cn  
$_SERVER["REQUEST_URI"]  //获取域名后的详细地址 如：/index.php?id=123 ...  
$_SERVER['PHP_SELF']  //获取PHP文件名  
$_SERVER["QUERY_STRING"]  //获取PHP后的网址参数  
$_SERVER['HTTP_REFERER']  //来源网页的详细地址  
```

#####   2.5 常见的算法

```php
//冒泡
function bubble_sort($arr) {
	$n=count($arr);
	for($i=0;$i<$n-1;$i++){
	    for($j=$i+1;$j<$n;$j++) {
	        if($arr[$j]<$arr[$i]) {
	            $temp=$arr[$i];
	            $arr[$i]=$arr[$j];
	            $arr[$j]=$temp;
	        }
	    }
	}
	return $arr;
}

//快排
function quick_sort($arr){
	$n=count($arr);
	if($n<=1)
	    return $arr;
	$key=$arr[0];
	$left_arr=array();
	$right_arr=array();
	for($i=1;$i<$n;$i++) {
	    if($arr[$i]<=$key)
	        $left_arr[]=$arr[$i];
	    else
	        $right_arr[]=$arr[$i];
	}
	$left_arr=quick_sort($left_arr);
	$right_arr=quick_sort($right_arr);
	return array_merge($left_arr,array($key),$right_arr);
}
```

##### 2.6 cgi,fast-cgi,php-fpm是什么

cgi:是web服务器和web应用之间进行数据交互的一种协议
fast-cgi:同cgi类似，效率上做了一些优化，先fork一个master,初始化执行环境后，然后fork几个worker,请求过来之后，master分配给其中一个worker,然后就可以接受下一个请求
php-fpm:是实现fast-cgi的接口程序，同时还提供了一些很智能的任务管理

##### 2.7 什么是xss攻击，php怎么预防xss攻击

xss攻击： XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序 

php可以通过`htmlspecialchars()`函数来防止xss攻击，一般情况下，该函数需要加第二个参数` ENT_COMPAT `,因为不加这个参数，只对双引号进行转义，加上后会对单引号进行转义

##### 2.8 php怎么防止sql注入

一般都是通过pdo或者mysqli来预防sql注入的，或者可以通过一些函数来预防如`mysql_real_escape_string()`

##### 2.9 php的垃圾回收机制

php变量（zval结构）都是由四部分组成:`变量类型（type）`、`值(value)`、`引用计数次数(refcount_gc)`、`是否是引用变量(is_ref_gc)`

php5.3之前： 当变量a赋值给变量b的时候，并没有立刻生成一个新的变量容器，而是将变量b指向了变量a指向的变量容器，即内存"共享"；而当变量b其中一个元素发生改变时，才会真正发生变量容器复制，这就是`写时复制技术` ，`当ref_count变成0的时候，该变量容器就会被销毁,这就是php5.3之前的垃圾回收机制`

 因为现有的垃圾回收机制可能会造成内存泄漏，如： 当数组或对象内部子元素引用其父元素，而此时如果发生了删除其父元素的情况，此变量容器并不会被删除 ，因为其子元素还在指向该变量容器，但是由于所有作用域内都没有指向该变量容器的符号，所以无法被清除，就会造成内存泄露，直到脚本执行结束

php5.3之后: `引入了根缓冲机制，php启动时默认设置zval数量，默认是10000，当php发现存在循环引用的zval时，就会 投入根缓冲区，当达到根缓冲区数量上限时，就会进行垃圾回收，以此来解决内存泄漏的问题`

##### 2.10 laravel框架的特点

laravel框架主要是其依赖注入，很多东西都是服务，如，auth认证服务，缓存服务，DB服务，服务的使用就是绑定和解析

##### 2.11 什么是领域驱动设计

其实就是比mvc更细分的一种模式，能够解决的问题是软件的复杂性问题，如果预期软件后期会发展的比较复杂，就可以考虑使用领域驱动设计，但是需要实现大量的封装和隔离，所以前期开发成本比较高

具体划分有：实体（entity,也就是代码里的模型），服务（service,某些操作不是明显不属于实体的，就可以在service中完成，比如一个比较复杂的操作），工厂（factory,是对复杂对象的创建）仓库（repository,负责基础信息的查询和持久化），模块(module,对于一个庞大的系统可以区分成不同的模块，比如订单，资源，操作，财务，是对前面各个部分的整合)

##### 2.12 include和require的区别

include遇到错误时会报warning警告，程序继续执行，require会报error错误，程序停止运行

include是在用到时加载，require是在一开始就加载

##### 2.13 传值和传引用

传值：把实参赋值给形参，对形参的修改不会影响实参

传引用：真正的以地址的方式传递参数，实参和形参是同一个对象，只不过是名字不同，对形参的修改会影响到实参

##### 2.14 psr-4 自动加载规范

1. 完整的类名**必须**要有一个顶级命名空间，被称为 "vendor namespace"；
2. 完整的类名**可以**有一个或多个子命名空间；
3. 完整的类名**必须**有一个最终的类名；
4. 完整的类名中任意一部分中的下滑线都是没有特殊含义的；
5. 完整的类名**可以**由任意大小写字母组成；
6. 所有类名都**必须**是大小写敏感的。
7. 当根据完整的类名载入相应的文件……
8. 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为“命名空间前缀”，其必须与至少一个“文件基目录”相对应；
9. 紧接命名空间前缀后的子命名空间**必须**与相应的”文件基目录“相匹配，其中的命名空间分隔符将作为目录分隔符。
10. 末尾的类名**必须**与对应的以 `.php` 为后缀的文件同名。
11. 自动加载器（autoloader）的实现**一定不能**抛出异常、**一定不能**触发任一级别的错误信息以及**不应该**有返回值。

##### 2.15 composer加载流程

1. 加载`autoload_real.php`文件，执行`getLoader()`方法
2. 首先判断是否是单例
3. 构建`ClassLoader`核心类
4. 初始化核心类对象，并且判断php版本是否大于5.6 
5. 如果大于，初始话`autoload_static`静态类，这个类里面定义了顶级命名空间长度数组，psr4顶级命名空间映射数组,psr2顶级命名空间映射数组，还定义了所有的命名空间映射数组
6. 如果不大于，通过加载四个数组文件，通过`loder`实例具体的方法把这些数组设置属性
7. 然后就是注册自动加载核心类对象，其核心是函数`loadClass`
8. 还定义了全局函数的自动加载
9. 具体运行的时候，先通过`findFile（）`去所有的命名空间映射数组中找，如果找不到，就去给命名空间添加后缀名，执行的是`findFileWithExtension（）`，然后去顶级命名空间长度数组中找这个命名空间的长度，然后再通过顶级命名空间映射数组找到对应文件位置，如果存在加载该文件，不存在就继续在顶级命名空间映射数组中找

### 3.redis相关

##### 3.1 redis的数据类型有哪些，分别用来做什么

String：缓存、计数器、分布式锁等。
List：链表、队列、微博关注人时间轴列表等。
Hash：用户信息、Hash 表等。
Set（集合）：去重、赞、踩、共同好友等。
Zset（有序集合）：访问量排行榜、点击量排行榜等。

##### 3.2 redis是怎么持久化的

redis持久化有两种一种是 快照（RDB持久化），一种是AOF持久化
快照是每隔一段时间保存一次数据快照
持久化是记录每一条写操作，有三种方式选择 ：

1.一种是写入AOF文件由系统决定，缓存区满就写入，效率高，

2.还有一种是一秒写入AOF文件一次，最对丢失一秒钟的缓存数据

3.还有一种是 每次写操作 都写入AOF文件,效率最低，但是最安全

##### 3.3 redis的过期策略是什么

tips:set指令是可以设置过期时间的

1.定时删除：每设置了一个含有过期时间的key都会创建一个定时器，过期之后立即删除，对内存很友好，但是占用大量CPU资源
2.惰性删除：在访问一个key的时候，会判断这个key是否过期，如果过期就删除，但是对内存不友好，某些极端情况下，大量的key都不会被删除
3.定期删除：每个一段时间扫描redis中的过期的key,并删除

在redis中使用的是定期删除和惰性删除策略,在启动时注册了serverCron函数，每一个时间时钟周期，都会抽取expires字典中的部分key进行清理，从而实现定期删除。另外，Redis会在访问key时判断key是否过期，如果过期了，就删除，以及每一次Redis访问事件到来时，beforeSleep都会调用activeExpireCycle函数，在1ms时间内主动清理部分key，这是惰性删除的实现。

##### 3.4 redis超出内存会怎么办，内存淘汰机制是什么,回收的算法是什么

1.noeviction：内存不足，写操作失败（2.xx版本默认的）
2.allkeys-lru：移除最近最少使用的key（最常用的）
3.allkeys-random：随机移除
4.volatile-lru：在设置了过去时间的key中移除最近最少使用的key(3.2版本默认的)
5.volatile-random：在设置了过期时间的key中随机移除
6.volatile-ttl：在设置了过期时间的key中 有更早过期时间的被移除

LRU算法

##### 3.5 redis为什么这么快,redis为什么是单线程的

1.完全基于内存，类似于hashmap,查询和操作的时间复杂度都是O(1)
2.数据结构简单
3.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作
4.使用多路I/O复用模型，非阻塞IO

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了

##### 3.6 Redis比memcached有哪些优势

1.memecached的数据类型都是字符串，redis有多种数据类型

2.redis的速度比memcached快

3.redis能够持久化数据

##### 3.7 redis中string类型的值最大可以存多少

512M

##### 3.8 redis为什么要把所有数据放到内存中

因为redis为了达到最快的读写速度，磁盘I/O严重影响redis的性能，redis的特点就是快速和持久化

##### 3.9 redis集群方案有哪些

1.**redis-cluster方案**(服务端分片技术,redis3.0开始支持)，其特点：

（1）每个节点都与n-1个节点通信，这被称为集群总线，通信使用的是特殊的端口号，及对外服务端口号+10000

（2）采用slot(槽)的概念，一共分为16384个槽，对于每个进入redis的键值对，都根据key进行散列，分配到16834个槽中，使用的算法是CRC16后16384取模 

（3）redis客户端只需要跟一个节点直连，不需要连所有的节点，当客户端操作的key没有在这个节点上时，redis会返回转向指令，指向正确的节点

（4） redis-trib.rb脚本（rub语言）为集群的管理工具，比如自动添加节点，规划槽位，迁移数据等一系列操作。 

（5）节点的失效是通过集群中超过半数的节点检测失效时才生效的

（6）为了增加集群的可访问性，官方推荐将节点配置成主从结构，一个主节点挂多个子节点，如果主节点失效，redis-cluster会通过选举算法从子节点中选择一个上升到主节点，继续工作

2.**中间件实行分片**，twemproxy

twemproxy特点：客户端不直接连接redis服务器，而是通过中间件间接访问redis服务器，这样客户端连接服务器的连接数，同时支持服务器水平扩展，单点的twemproxy很容易造成很大的压力，通常结合keepalived来实现高可用，通常一台在工作，另一台当备机，第一台挂掉之后，vip自动漂移，备机接替工作

3.**客户端实行分片**，其特点是：

分区的逻辑在客户端实现，有客户端选择请求哪个节点，方案可以参考一致性哈希。

**一致性哈希简介**：将整个哈希值空间组织成一个圆，从0-2的32次方减1，针对不同的服务器ip+port通过hash算法会落在这个圆上的某一个位置，假如有4台服务器，且落在90度，180度，270度和360度这四个节点，那么当有数据存入的时候，该数据的key也通过hash落在这个圆的某个位置，然后顺时针下一个节点就是该数据存在哪个服务器上，读取时也是类似的顺时针下一个节点读取数据，如果某一个服务器挂掉，那么只有这台服务器所在位置逆时针到上一台服务器所在位置之间的数据存储和读取有问题，不会影响其他，加一台服务器也是类似的情况，假如整个圆上只有两台服务器，且位置离的很近，那么就会造成大量的数据存入第一台服务器，这时候就可以考虑**虚拟节点**，为服务器ip+port后加上计数，(如： “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3” )然后再进行hash ，落在这些虚拟节点上的数据，通过映射就可以找到真实的地址，这样就能解决数据分布不均匀的问题

4.**codis**，其特点是：

（1）数据根据key分布在1024个slot(槽)内，分配算法是 CRC32后key 取模，每个codis-server负责一部分数据

（2）codis模块有：codis server, codis proxy, codis dashborad,codis HA 等，客户端连接codis proxy,通过 proxy来间接连接codis server,对于一个业务集群来说，可以同时部署多个codis-proxy实例，不同proxy之间通过dashborad来保证状态同步

##### 3.10 mysql里有2000w数据 redis中只存20w的数据 如何保证redis中的数据都是热点数据

计算20W数据所需要占的内存，设置redis的内存上限，过期策略设置为**volatile-ttl：在设置了过期时间的key中 有更早过期时间的被移除**，每次用户登录时记录或者更新用户的登录时间，设置其保存时长

##### 3.11 redis怎么设置密码，怎么验证密码

redis的配置文件中有个参数时requirepass 该参数就是用来设置密码的，登录的时候，通过`AUTH 'password'`来验证密码

##### 3.12 redis 哈希槽的概念

redis集群中有16834个哈希槽，每个key通过CRC16(key)取模的方法决定放置在哪个槽中，每个节点负责一部分的hash槽，使用hash槽的好处是：更方便的移除和新增节点

##### 3.13 redis的主从复制模型是什么

为了在某些节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品

##### 3.14 redis集群会有写操作丢失吗，为什么

redis并不能保证数据的强一致性，这意味着在某种特定场景下可能会丢失写操作

##### 3.15 redis集群之间如何复制，redis如何做内存优化

1.异步复制

2.尽量使用散列表，因为散列表消耗的内存最小，如在web系统的用户对象，不要为姓名，性别，邮箱，密码等设置专门的key,要把用户的所有信息存在一个散列表中

##### 3.16 redis中的管道是什么，有什么用

redis的管道技术是指在服务端未响应时，客户端可以多次向服务端发送请求，并最终一次性获取所有服务端的请求，用处是提高redis服务的性能

```php
$redis = new Redis();

$redis->connect('localhost',6379);

$redis->auth("1234567890");

$pipe=$redis->multi(Redis::PIPELINE);

for($i= 0 ; $i<  10000 ; $i++) {

       $pipe->set("key::$i",str_pad($i, 4,'0', 0));

       $pipe->get("key::$i");

}

$replies=$pipe->exec();

print_r($replies);
```



##### 3.17怎么理解redis的事务，相关命令有哪些

事务是一个单独的隔离操作，事务的所有命令都会序列化、按顺序的执行，事务在执行过程中不会被其他客户端发来的命令请求所打断，事务中的所有命令，要么全部成功要么全部失败

MULTI,EXEC,DISCARD,WATCH

##### 3.18 redis设置过期时间和永不失效

EXPIRE   PERSIST 

##### 3.19 一个redis实例可以存放多少个key

理论上可以存放 2的32次方个key,在实际测试中，每个实例最少存放2亿5千万个key

##### 3.20 redis 常见的性能问题和解决方案

1.Master最好不要做任何持久化的工作

2.如果数据比较重要，在某个子服务器上开启AOF备份数据，最好是一秒钟一次

3.主从最好是在一个局域网内，为了主从复制的速度和稳定性

4.主从复制不要用图状结构，要用单链表的结构更稳定

